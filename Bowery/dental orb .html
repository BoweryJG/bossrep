<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dental Orb - Fluid Animation</title>
  <style>
    body {
      background: transparent;
      margin: 0;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    svg {
      width: 100vw;
      height: 100vh;
      display: block;
      background: transparent;
      position: fixed;
      top: 0;
      left: 0;
      pointer-events: none; /* SVG doesn't block scrolling/touch */
      touch-action: none;
    }
  </style>
</head>
<body>
<svg id="orbSVG" style="display:block; margin:auto; position:absolute; left:50%; top:48px; transform:translateX(-50%);">

  <defs>
    <filter id="turbulence" x="-50%" y="-50%" width="200%" height="200%">
      <feTurbulence id="turbulenceFilter" type="fractalNoise" baseFrequency="0.01 0.01" numOctaves="1" seed="1" />
      <feDisplacementMap in="SourceGraphic" scale="15" />
    </filter>
    
    <!-- Multiple gradients that will be animated and blended -->
    <radialGradient id="parentGrad1" cx="50%" cy="50%" r="70%">
      <stop id="p1a" offset="0%" stop-color="#0f3d91"/>
      <stop id="p1b" offset="40%" stop-color="#1e6bb8"/>
      <stop id="p1c" offset="70%" stop-color="#2ec4b6"/>
      <stop id="p1d" offset="100%" stop-color="#3a86ff"/>
    </radialGradient>
    
    <radialGradient id="parentGrad2" cx="50%" cy="50%" r="70%">
      <stop id="p2a" offset="0%" stop-color="#5f0a87"/>
      <stop id="p2b" offset="40%" stop-color="#6a0572"/>
      <stop id="p2c" offset="70%" stop-color="#2d1e6b"/>
      <stop id="p2d" offset="100%" stop-color="#0b2545"/>
    </radialGradient>
    
    <linearGradient id="parentGrad3" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop id="p3a" offset="0%" stop-color="#0f3d91"/>
      <stop id="p3b" offset="50%" stop-color="#3a86ff"/>
      <stop id="p3c" offset="100%" stop-color="#2ec4b6"/>
    </linearGradient>
    
    <!-- Mask for the orb shape -->
    <mask id="orbMask">
      <circle id="maskCircle" cx="50%" cy="50%" r="100" fill="white" />
    </mask>
    
    <!-- Blend mode for the gradients -->
    <filter id="blendFilter">
      <feBlend id="blendMode" mode="screen" in="SourceGraphic" in2="SourceGraphic" />
    </filter>
  </defs>
  
  <!-- Multiple layers for fluid effect -->
  <g id="orbGroup" mask="url(#orbMask)">
    <circle id="baseOrb" cx="50%" cy="50%" r="100" fill="url(#parentGrad1)" opacity="0.9" />
    <circle id="overlayOrb1" cx="50%" cy="50%" r="100" fill="url(#parentGrad2)" opacity="0.7" filter="url(#turbulence)" />
    <circle id="overlayOrb2" cx="50%" cy="50%" r="95" fill="url(#parentGrad3)" opacity="0.5" />
  </g>
</svg>
<script>
// --- Utility functions ---
function lerp(a, b, t) { return a + (b - a) * t; }
function hslToHex(h, s, l) {
  h /= 360; s /= 100; l /= 100;
  let r, g, b;
  if (s === 0) { r = g = b = l; }
  else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return "#" + [r, g, b].map(x => Math.round(x * 255).toString(16).padStart(2, "0")).join("");
}
function lerpColor(a, b, t) {
  const ah = parseInt(a.replace('#', ''), 16), bh = parseInt(b.replace('#', ''), 16);
  const ar = (ah >> 16) & 0xff, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
  const br = (bh >> 16) & 0xff, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
  const rr = Math.round(ar + (br - ar) * t);
  const rg = Math.round(ag + (bg - ag) * t);
  const rb = Math.round(ab + (bb - ab) * t);
  return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb).toString(16).slice(1);
}

const parentRadius = 100;

function adjustSVGSize() {
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const svg = document.getElementById('orbSVG');
  svg.setAttribute('width', vw);
  svg.setAttribute('height', vh);
  svg.setAttribute('viewBox', `0 0 ${vw} ${vh}`);
}

adjustSVGSize();
window.addEventListener('resize', adjustSVGSize);

// Function to generate smooth, organic blob shapes like in the reference image
function generateBlobPath(cx, cy, radius, points, irregularity, seed) {
  const path = [];
  const angleStep = (Math.PI * 2) / points;
  
  // Generate points around a circle with gentle, organic variations
  for (let i = 0; i < points; i++) {
    const angle = i * angleStep;
    
    // Create gentle, undulating variations
    // Use lower frequencies for more organic, blob-like shapes
    const variation = (
      Math.sin(angle * 2 + seed * 0.7) * 0.3 +
      Math.cos(angle * 1.5 + seed * 0.5) * 0.3 +
      Math.sin(angle * 1 + seed * 0.3) * 0.4
    ) * irregularity;
    
    // Apply smooth radius variation - no spikes, just gentle undulations
    const finalRadius = radius * (1 + variation);
    
    // Calculate point
    const x = cx + Math.cos(angle) * finalRadius;
    const y = cy + Math.sin(angle) * finalRadius;
    
    path.push({ x, y });
  }
  
  // Create SVG path with extra smoothing for organic, blob-like edges
  let svgPath = `M ${path[0].x},${path[0].y}`;
  
  // Use a cardinal spline approach for super smooth transitions
  for (let i = 0; i < points; i++) {
    const p0 = path[(i - 1 + points) % points];
    const p1 = path[i];
    const p2 = path[(i + 1) % points];
    const p3 = path[(i + 2) % points];
    
    // Extra smooth bezier curves with tension control
    const tension = 0.8; // Higher = smoother
    const cp1x = p1.x + (p2.x - p0.x) * tension / 6;
    const cp1y = p1.y + (p2.y - p0.y) * tension / 6;
    const cp2x = p2.x - (p3.x - p1.x) * tension / 6;
    const cp2y = p2.y - (p3.y - p1.y) * tension / 6;
    
    svgPath += ` C ${cp1x},${cp1y} ${cp2x},${cp2y} ${p2.x},${p2.y}`;
  }
  
  svgPath += ' Z';
  return svgPath;
}

function animate() {
  const now = performance.now();
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const cx = vw / 2;
  const cy = vh / 2;
  
  // Animate the unified gradient for flowing effect
  const gradCx = 50 + 10 * Math.sin(now * 0.0002);
  const gradCy = 50 + 10 * Math.cos(now * 0.00018);
  document.getElementById('unifiedGradient').setAttribute('cx', `${gradCx}%`);
  document.getElementById('unifiedGradient').setAttribute('cy', `${gradCy}%`);
  
  // Animate the gradient colors for beautiful transitions
  const gradColors = [
    {id:'g1', base:'#0f3d91', alt:'#2d1e6b'},
    {id:'g2', base:'#1e6bb8', alt:'#3a86ff'},
    {id:'g3', base:'#2ec4b6', alt:'#0b2545'},
    {id:'g4', base:'#3a86ff', alt:'#5f0a87'}
  ];
  
  // Apply smooth color animations
  gradColors.forEach((stop, i) => {
    const phase = now * 0.0001 + i * 0.7;
    const tt = 0.5 + 0.5 * Math.sin(phase + Math.sin(phase * 0.5));
    const color = lerpColor(stop.base, stop.alt, tt);
    document.getElementById(stop.id).setAttribute('stop-color', color);
  });
  
  // Generate a single, beautiful blob shape
  const orbRadius = parentRadius * (1 + 0.05 * Math.sin(now * 0.0003));
  const orbSeed = now * 0.0001;
  
  // Use more points for smoother edges
  const pointCount = 12;
  
  // Gentle irregularity for natural, organic shape
  const irregularity = 0.15 + 0.05 * Math.sin(now * 0.0002);
  
  // Generate the unified orb path
  const orbPath = generateBlobPath(cx, cy, orbRadius, pointCount, irregularity, orbSeed);
  document.getElementById('unifiedOrb').setAttribute('d', orbPath);
  
  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
