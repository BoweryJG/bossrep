<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dental Orb - Fluid Animation</title>
  <style>
    body {
      background: transparent;
      margin: 0;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    svg {
      width: 100vw;
      height: 100vh;
      display: block;
      background: transparent;
      position: fixed;
      top: 0;
      left: 0;
      pointer-events: none; /* SVG doesn't block scrolling/touch */
      touch-action: none;
    }
  </style>
</head>
<body>
<svg id="orbSVG" style="display:block; margin:auto; position:absolute; left:50%; top:48px; transform:translateX(-50%);">

  <defs>
    <!-- Single unified filter for beautiful, cohesive edges -->
    <filter id="unifiedOrbFilter" x="-50%" y="-50%" width="200%" height="200%">
      <!-- Subtle turbulence for internal texture -->
      <feTurbulence type="fractalNoise" baseFrequency="0.01 0.01" numOctaves="2" seed="1" result="turbulence" />
      <feDisplacementMap in="SourceGraphic" in2="turbulence" scale="5" result="displaced" />
      
      <!-- Glow for beautiful edge treatment -->
      <feGaussianBlur in="displaced" stdDeviation="3" result="blur" />
      <feComposite in="displaced" in2="blur" operator="over" result="softEdges" />
      
      <!-- Color adjustments for richness -->
      <feColorMatrix in="softEdges" type="matrix" 
                   values="1.1 0 0 0 0
                           0 1.1 0 0 0
                           0 0 1.2 0 0
                           0 0 0 1 0" result="colorEnhanced" />
    </filter>
    
    <!-- Single beautiful gradient with dental colors -->
    <radialGradient id="unifiedGradient" cx="50%" cy="50%" r="70%">
      <stop id="g1" offset="0%" stop-color="#0f3d91"/>
      <stop id="g2" offset="35%" stop-color="#1e6bb8"/>
      <stop id="g3" offset="65%" stop-color="#2ec4b6"/>
      <stop id="g4" offset="100%" stop-color="#3a86ff"/>
    </radialGradient>
  </defs>
  
  <!-- Single unified orb with beautiful edges -->
  <g id="orbGroup">
    <!-- Just one path for the entire orb -->
    <path id="unifiedOrb" d="" fill="url(#unifiedGradient)" filter="url(#unifiedOrbFilter)" />
  </g>
</svg>
<script>
// --- Utility functions ---
function lerp(a, b, t) { return a + (b - a) * t; }
function hslToHex(h, s, l) {
  h /= 360; s /= 100; l /= 100;
  let r, g, b;
  if (s === 0) { r = g = b = l; }
  else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return "#" + [r, g, b].map(x => Math.round(x * 255).toString(16).padStart(2, "0")).join("");
}
function lerpColor(a, b, t) {
  const ah = parseInt(a.replace('#', ''), 16), bh = parseInt(b.replace('#', ''), 16);
  const ar = (ah >> 16) & 0xff, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
  const br = (bh >> 16) & 0xff, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
  const rr = Math.round(ar + (br - ar) * t);
  const rg = Math.round(ag + (bg - ag) * t);
  const rb = Math.round(ab + (bb - ab) * t);
  return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb).toString(16).slice(1);
}

const parentRadius = 100;

function adjustSVGSize() {
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const svg = document.getElementById('orbSVG');
  svg.setAttribute('width', vw);
  svg.setAttribute('height', vh);
  svg.setAttribute('viewBox', `0 0 ${vw} ${vh}`);
}

adjustSVGSize();
window.addEventListener('resize', adjustSVGSize);

// Function to generate smooth, organic blob shapes like in the reference image
function generateBlobPath(cx, cy, radius, points, irregularity, seed) {
  const path = [];
  const angleStep = (Math.PI * 2) / points;
  
  // Generate points around a circle with gentle, organic variations
  for (let i = 0; i < points; i++) {
    const angle = i * angleStep;
    
    // Create gentle, undulating variations
    // Use lower frequencies for more organic, blob-like shapes
    const variation = (
      Math.sin(angle * 2 + seed * 0.7) * 0.3 +
      Math.cos(angle * 1.5 + seed * 0.5) * 0.3 +
      Math.sin(angle * 1 + seed * 0.3) * 0.4
    ) * irregularity;
    
    // Apply smooth radius variation - no spikes, just gentle undulations
    const finalRadius = radius * (1 + variation);
    
    // Calculate point
    const x = cx + Math.cos(angle) * finalRadius;
    const y = cy + Math.sin(angle) * finalRadius;
    
    path.push({ x, y });
  }
  
  // Create SVG path with extra smoothing for organic, blob-like edges
  let svgPath = `M ${path[0].x},${path[0].y}`;
  
  // Use a cardinal spline approach for super smooth transitions
  for (let i = 0; i < points; i++) {
    const p0 = path[(i - 1 + points) % points];
    const p1 = path[i];
    const p2 = path[(i + 1) % points];
    const p3 = path[(i + 2) % points];
    
    // Extra smooth bezier curves with tension control
    const tension = 0.8; // Higher = smoother
    const cp1x = p1.x + (p2.x - p0.x) * tension / 6;
    const cp1y = p1.y + (p2.y - p0.y) * tension / 6;
    const cp2x = p2.x - (p3.x - p1.x) * tension / 6;
    const cp2y = p2.y - (p3.y - p1.y) * tension / 6;
    
    svgPath += ` C ${cp1x},${cp1y} ${cp2x},${cp2y} ${p2.x},${p2.y}`;
  }
  
  svgPath += ' Z';
  return svgPath;
}

function animate() {
  const now = performance.now();
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const cx = vw / 2;
  const cy = vh / 2;
  
  // Animate turbulence for fluid-like movement
  const turbFreqX = 0.01 + 0.005 * Math.sin(now * 0.00017);
  const turbFreqY = 0.01 + 0.005 * Math.cos(now * 0.00019);
  const turbScale = 10 + 5 * Math.sin(now * 0.0003);
  const turbSeed = Math.floor(now * 0.001) % 100;
  document.getElementById('turbulenceFilter').setAttribute('baseFrequency', `${turbFreqX} ${turbFreqY}`);
  document.getElementById('turbulenceFilter').setAttribute('seed', turbSeed);
  
  // Animate gradient positions for flowing effect
  const grad1cx = 50 + 15 * Math.sin(now * 0.0002);
  const grad1cy = 50 + 15 * Math.cos(now * 0.00018);
  const grad2cx = 50 + 15 * Math.sin(now * 0.00022 + 2);
  const grad2cy = 50 + 15 * Math.cos(now * 0.00019 + 1);
  document.getElementById('parentGrad1').setAttribute('cx', `${grad1cx}%`);
  document.getElementById('parentGrad1').setAttribute('cy', `${grad1cy}%`);
  document.getElementById('parentGrad2').setAttribute('cx', `${grad2cx}%`);
  document.getElementById('parentGrad2').setAttribute('cy', `${grad2cy}%`);
  
  // Animate linear gradient angle
  const angle = (now * 0.01) % 360;
  const x1 = 50 + 50 * Math.cos(angle * Math.PI / 180);
  const y1 = 50 + 50 * Math.sin(angle * Math.PI / 180);
  const x2 = 50 + 50 * Math.cos((angle + 180) * Math.PI / 180);
  const y2 = 50 + 50 * Math.sin((angle + 180) * Math.PI / 180);
  document.getElementById('parentGrad3').setAttribute('x1', `${x1}%`);
  document.getElementById('parentGrad3').setAttribute('y1', `${y1}%`);
  document.getElementById('parentGrad3').setAttribute('x2', `${x2}%`);
  document.getElementById('parentGrad3').setAttribute('y2', `${y2}%`);
  
  // Animate gradient colors for first radial gradient
  const grad1Colors = [
    {id:'p1a', base:'#0f3d91', alt:'#2d1e6b'},
    {id:'p1b', base:'#1e6bb8', alt:'#3a86ff'},
    {id:'p1c', base:'#2ec4b6', alt:'#0b2545'},
    {id:'p1d', base:'#3a86ff', alt:'#5f0a87'}
  ];
  
  // Animate gradient colors for second radial gradient
  const grad2Colors = [
    {id:'p2a', base:'#5f0a87', alt:'#0f3d91'},
    {id:'p2b', base:'#6a0572', alt:'#2ec4b6'},
    {id:'p2c', base:'#2d1e6b', alt:'#1e6bb8'},
    {id:'p2d', base:'#0b2545', alt:'#3a86ff'}
  ];
  
  // Animate gradient colors for linear gradient
  const grad3Colors = [
    {id:'p3a', base:'#0f3d91', alt:'#6a0572'},
    {id:'p3b', base:'#3a86ff', alt:'#2d1e6b'},
    {id:'p3c', base:'#2ec4b6', alt:'#5f0a87'}
  ];
  
  // Apply color animations to all gradients with different phases
  [grad1Colors, grad2Colors, grad3Colors].forEach((gradColors, gradIndex) => {
    gradColors.forEach((stop, i) => {
      const phase = now * 0.0001 + i * 0.7 + gradIndex * 1.3;
      const tt = 0.5 + 0.5 * Math.sin(phase + Math.sin(phase * 0.5));
      const color = lerpColor(stop.base, stop.alt, tt);
      document.getElementById(stop.id).setAttribute('stop-color', color);
    });
  });
  
  // Generate smooth, organic blob shapes with different seeds and properties
  const baseRadius = parentRadius * (1 + 0.05 * Math.sin(now * 0.0003));
  const baseSeed = now * 0.0001;
  const baseIrregularity = 0.12 + 0.04 * Math.sin(now * 0.0002);
  const basePath = generateBlobPath(cx, cy, baseRadius, 8, baseIrregularity, baseSeed);
  document.getElementById('baseOrb').setAttribute('d', basePath);
  
  // Second layer - slightly different blob pattern
  const overlay1Radius = baseRadius * 0.95;
  const overlay1Seed = now * 0.00012 + 100;
  const overlay1Irregularity = 0.14 + 0.05 * Math.sin(now * 0.00018);
  const overlay1Path = generateBlobPath(cx + 8 * Math.sin(now * 0.0002), cy + 8 * Math.cos(now * 0.00018), 
                                       overlay1Radius, 7, overlay1Irregularity, overlay1Seed);
  document.getElementById('overlayOrb1').setAttribute('d', overlay1Path);
  
  // Third layer - inner blob layer
  const overlay2Radius = baseRadius * 0.9;
  const overlay2Seed = now * 0.00014 + 200;
  const overlay2Irregularity = 0.16 + 0.06 * Math.sin(now * 0.00016);
  const overlay2Path = generateBlobPath(cx + 5 * Math.sin(now * 0.00025 + 1), cy + 5 * Math.cos(now * 0.0002 + 2), 
                                       overlay2Radius, 6, overlay2Irregularity, overlay2Seed);
  document.getElementById('overlayOrb2').setAttribute('d', overlay2Path);
  
  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
