<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dental Orb - Fluid Animation</title>
  <style>
    body {
      background: transparent;
      margin: 0;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    svg {
      width: 100vw;
      height: 100vh;
      display: block;
      background: transparent;
      position: fixed;
      top: 0;
      left: 0;
      pointer-events: none; /* SVG doesn't block scrolling/touch */
      touch-action: none;
    }
  </style>
</head>
<body>
<svg id="orbSVG" style="display:block; margin:auto; position:absolute; left:50%; top:48px; transform:translateX(-50%);">

  <defs>
    <!-- Enhanced turbulence with blur for seamless edges -->
    <filter id="turbulence" x="-50%" y="-50%" width="200%" height="200%">
      <feTurbulence id="turbulenceFilter" type="fractalNoise" baseFrequency="0.01 0.01" numOctaves="2" seed="1" />
      <feDisplacementMap in="SourceGraphic" scale="15" />
      <feGaussianBlur stdDeviation="2" />
      <feComposite in="SourceGraphic" operator="atop" />
    </filter>
    
    <!-- Glow filter for seamless edges -->
    <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="5" result="blur" />
      <feComposite in="SourceGraphic" in2="blur" operator="over" />
    </filter>
    
    <!-- Blend filter for organic transitions -->
    <filter id="organicBlend">
      <feGaussianBlur stdDeviation="3" />
      <feColorMatrix type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -7" />
    </filter>
    
    <!-- Multiple gradients that will be animated and blended -->
    <radialGradient id="parentGrad1" cx="50%" cy="50%" r="70%">
      <stop id="p1a" offset="0%" stop-color="#0f3d91"/>
      <stop id="p1b" offset="40%" stop-color="#1e6bb8"/>
      <stop id="p1c" offset="70%" stop-color="#2ec4b6"/>
      <stop id="p1d" offset="100%" stop-color="#3a86ff"/>
    </radialGradient>
    
    <radialGradient id="parentGrad2" cx="50%" cy="50%" r="70%">
      <stop id="p2a" offset="0%" stop-color="#5f0a87"/>
      <stop id="p2b" offset="40%" stop-color="#6a0572"/>
      <stop id="p2c" offset="70%" stop-color="#2d1e6b"/>
      <stop id="p2d" offset="100%" stop-color="#0b2545"/>
    </radialGradient>
    
    <linearGradient id="parentGrad3" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop id="p3a" offset="0%" stop-color="#0f3d91"/>
      <stop id="p3b" offset="50%" stop-color="#3a86ff"/>
      <stop id="p3c" offset="100%" stop-color="#2ec4b6"/>
    </linearGradient>
    
    <!-- Mask for the orb shape -->
    <mask id="orbMask">
      <circle id="maskCircle" cx="50%" cy="50%" r="100" fill="white" />
    </mask>
    
    <!-- Blend mode for the gradients -->
    <filter id="blendFilter">
      <feBlend id="blendMode" mode="screen" in="SourceGraphic" in2="SourceGraphic" />
    </filter>
  </defs>
  
  <!-- Organic blob-like orb with undulating edges -->
  <g id="orbGroup">
    <!-- Base layer with organic shape -->
    <path id="baseOrb" d="" fill="url(#parentGrad1)" opacity="0.95" filter="url(#glow)" />
    
    <!-- Overlay layers with organic shapes -->
    <path id="overlayOrb1" d="" fill="url(#parentGrad2)" opacity="0.85" filter="url(#turbulence)" style="mix-blend-mode: soft-light;" />
    
    <path id="overlayOrb2" d="" fill="url(#parentGrad3)" opacity="0.75" filter="url(#organicBlend)" style="mix-blend-mode: overlay;" />
  </g>
</svg>
<script>
// --- Utility functions ---
function lerp(a, b, t) { return a + (b - a) * t; }
function hslToHex(h, s, l) {
  h /= 360; s /= 100; l /= 100;
  let r, g, b;
  if (s === 0) { r = g = b = l; }
  else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return "#" + [r, g, b].map(x => Math.round(x * 255).toString(16).padStart(2, "0")).join("");
}
function lerpColor(a, b, t) {
  const ah = parseInt(a.replace('#', ''), 16), bh = parseInt(b.replace('#', ''), 16);
  const ar = (ah >> 16) & 0xff, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
  const br = (bh >> 16) & 0xff, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
  const rr = Math.round(ar + (br - ar) * t);
  const rg = Math.round(ag + (bg - ag) * t);
  const rb = Math.round(ab + (bb - ab) * t);
  return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb).toString(16).slice(1);
}

const parentRadius = 100;

function adjustSVGSize() {
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const svg = document.getElementById('orbSVG');
  svg.setAttribute('width', vw);
  svg.setAttribute('height', vh);
  svg.setAttribute('viewBox', `0 0 ${vw} ${vh}`);
}

adjustSVGSize();
window.addEventListener('resize', adjustSVGSize);

// Function to generate organic blob shapes
function generateBlobPath(cx, cy, radius, points, irregularity, spikiness, seed) {
  const path = [];
  const angleStep = (Math.PI * 2) / points;
  
  // Generate points around a circle with random variations
  for (let i = 0; i < points; i++) {
    const angle = i * angleStep;
    
    // Add randomness to the radius
    const rand = Math.sin(angle * 3 + seed) * Math.cos(angle * 5 + seed * 0.7) * Math.sin(angle * 7 + seed * 0.3);
    const radiusVariation = 1 + (rand * irregularity);
    const currentRadius = radius * radiusVariation;
    
    // Add spikes/dents
    const spikeFreq = 4 + Math.floor(Math.sin(seed * 0.01) * 3);
    const spike = Math.sin(angle * spikeFreq + seed * 0.2) * spikiness;
    const finalRadius = currentRadius * (1 + spike);
    
    // Calculate point
    const x = cx + Math.cos(angle) * finalRadius;
    const y = cy + Math.sin(angle) * finalRadius;
    
    path.push({ x, y });
  }
  
  // Create SVG path string with bezier curves for smoothness
  let svgPath = `M ${path[0].x},${path[0].y}`;
  
  for (let i = 0; i < points; i++) {
    const p1 = path[i];
    const p2 = path[(i + 1) % points];
    
    // Control points for bezier curve
    const cp1x = p1.x + (p2.x - p1.x) * 0.5 - (path[(i + 2) % points].y - p1.y) * 0.2;
    const cp1y = p1.y + (p2.y - p1.y) * 0.5 + (path[(i + 2) % points].x - p1.x) * 0.2;
    
    svgPath += ` C ${cp1x},${cp1y} ${cp1x},${cp1y} ${p2.x},${p2.y}`;
  }
  
  svgPath += ' Z';
  return svgPath;
}

function animate() {
  const now = performance.now();
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const cx = vw / 2;
  const cy = vh / 2;
  
  // Animate turbulence for fluid-like movement
  const turbFreqX = 0.01 + 0.005 * Math.sin(now * 0.00017);
  const turbFreqY = 0.01 + 0.005 * Math.cos(now * 0.00019);
  const turbScale = 10 + 5 * Math.sin(now * 0.0003);
  const turbSeed = Math.floor(now * 0.001) % 100;
  document.getElementById('turbulenceFilter').setAttribute('baseFrequency', `${turbFreqX} ${turbFreqY}`);
  document.getElementById('turbulenceFilter').setAttribute('seed', turbSeed);
  
  // Animate gradient positions for flowing effect
  const grad1cx = 50 + 15 * Math.sin(now * 0.0002);
  const grad1cy = 50 + 15 * Math.cos(now * 0.00018);
  const grad2cx = 50 + 15 * Math.sin(now * 0.00022 + 2);
  const grad2cy = 50 + 15 * Math.cos(now * 0.00019 + 1);
  document.getElementById('parentGrad1').setAttribute('cx', `${grad1cx}%`);
  document.getElementById('parentGrad1').setAttribute('cy', `${grad1cy}%`);
  document.getElementById('parentGrad2').setAttribute('cx', `${grad2cx}%`);
  document.getElementById('parentGrad2').setAttribute('cy', `${grad2cy}%`);
  
  // Animate linear gradient angle
  const angle = (now * 0.01) % 360;
  const x1 = 50 + 50 * Math.cos(angle * Math.PI / 180);
  const y1 = 50 + 50 * Math.sin(angle * Math.PI / 180);
  const x2 = 50 + 50 * Math.cos((angle + 180) * Math.PI / 180);
  const y2 = 50 + 50 * Math.sin((angle + 180) * Math.PI / 180);
  document.getElementById('parentGrad3').setAttribute('x1', `${x1}%`);
  document.getElementById('parentGrad3').setAttribute('y1', `${y1}%`);
  document.getElementById('parentGrad3').setAttribute('x2', `${x2}%`);
  document.getElementById('parentGrad3').setAttribute('y2', `${y2}%`);
  
  // Animate gradient colors for first radial gradient
  const grad1Colors = [
    {id:'p1a', base:'#0f3d91', alt:'#2d1e6b'},
    {id:'p1b', base:'#1e6bb8', alt:'#3a86ff'},
    {id:'p1c', base:'#2ec4b6', alt:'#0b2545'},
    {id:'p1d', base:'#3a86ff', alt:'#5f0a87'}
  ];
  
  // Animate gradient colors for second radial gradient
  const grad2Colors = [
    {id:'p2a', base:'#5f0a87', alt:'#0f3d91'},
    {id:'p2b', base:'#6a0572', alt:'#2ec4b6'},
    {id:'p2c', base:'#2d1e6b', alt:'#1e6bb8'},
    {id:'p2d', base:'#0b2545', alt:'#3a86ff'}
  ];
  
  // Animate gradient colors for linear gradient
  const grad3Colors = [
    {id:'p3a', base:'#0f3d91', alt:'#6a0572'},
    {id:'p3b', base:'#3a86ff', alt:'#2d1e6b'},
    {id:'p3c', base:'#2ec4b6', alt:'#5f0a87'}
  ];
  
  // Apply color animations to all gradients with different phases
  [grad1Colors, grad2Colors, grad3Colors].forEach((gradColors, gradIndex) => {
    gradColors.forEach((stop, i) => {
      const phase = now * 0.0001 + i * 0.7 + gradIndex * 1.3;
      const tt = 0.5 + 0.5 * Math.sin(phase + Math.sin(phase * 0.5));
      const color = lerpColor(stop.base, stop.alt, tt);
      document.getElementById(stop.id).setAttribute('stop-color', color);
    });
  });
  
  // Generate organic blob shapes with different seeds and properties
  const baseRadius = parentRadius * (1 + 0.05 * Math.sin(now * 0.0003));
  const baseSeed = now * 0.0001;
  const baseIrregularity = 0.12 + 0.04 * Math.sin(now * 0.0002);
  const baseSpikiness = 0.08 + 0.03 * Math.cos(now * 0.00015);
  const basePath = generateBlobPath(cx, cy, baseRadius, 12, baseIrregularity, baseSpikiness, baseSeed);
  document.getElementById('baseOrb').setAttribute('d', basePath);
  
  // Second layer - more irregular
  const overlay1Radius = baseRadius * 0.95;
  const overlay1Seed = now * 0.00012 + 100;
  const overlay1Irregularity = 0.15 + 0.05 * Math.sin(now * 0.00018);
  const overlay1Spikiness = 0.1 + 0.04 * Math.cos(now * 0.00013);
  const overlay1Path = generateBlobPath(cx + 8 * Math.sin(now * 0.0002), cy + 8 * Math.cos(now * 0.00018), 
                                       overlay1Radius, 10, overlay1Irregularity, overlay1Spikiness, overlay1Seed);
  document.getElementById('overlayOrb1').setAttribute('d', overlay1Path);
  
  // Third layer - most organic
  const overlay2Radius = baseRadius * 0.9;
  const overlay2Seed = now * 0.00014 + 200;
  const overlay2Irregularity = 0.18 + 0.06 * Math.sin(now * 0.00016);
  const overlay2Spikiness = 0.12 + 0.05 * Math.cos(now * 0.00011);
  const overlay2Path = generateBlobPath(cx + 5 * Math.sin(now * 0.00025 + 1), cy + 5 * Math.cos(now * 0.0002 + 2), 
                                       overlay2Radius, 8, overlay2Irregularity, overlay2Spikiness, overlay2Seed);
  document.getElementById('overlayOrb2').setAttribute('d', overlay2Path);
  
  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
