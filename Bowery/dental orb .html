<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dental Orb - Fluid Animation</title>
  <style>
    body {
      background: transparent;
      margin: 0;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    svg {
      width: 100vw;
      height: 100vh;
      display: block;
      background: transparent;
      position: fixed;
      top: 0;
      left: 0;
      pointer-events: none; /* SVG doesn't block scrolling/touch */
      touch-action: none;
    }
  </style>
</head>
<body>
<svg id="orbSVG" style="display:block; margin:auto; position:absolute; left:50%; top:48px; transform:translateX(-50%);">

  <defs>
    <!-- Enhanced turbulence with blur for seamless edges -->
    <filter id="turbulence" x="-50%" y="-50%" width="200%" height="200%">
      <feTurbulence id="turbulenceFilter" type="fractalNoise" baseFrequency="0.01 0.01" numOctaves="2" seed="1" />
      <feDisplacementMap in="SourceGraphic" scale="15" />
      <feGaussianBlur stdDeviation="2" />
      <feComposite in="SourceGraphic" operator="atop" />
    </filter>
    
    <!-- Glow filter for seamless edges -->
    <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="5" result="blur" />
      <feComposite in="SourceGraphic" in2="blur" operator="over" />
    </filter>
    
    <!-- Blend filter for organic transitions -->
    <filter id="organicBlend">
      <feGaussianBlur stdDeviation="3" />
      <feColorMatrix type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -7" />
    </filter>
    
    <!-- Multiple gradients that will be animated and blended -->
    <radialGradient id="parentGrad1" cx="50%" cy="50%" r="70%">
      <stop id="p1a" offset="0%" stop-color="#0f3d91"/>
      <stop id="p1b" offset="40%" stop-color="#1e6bb8"/>
      <stop id="p1c" offset="70%" stop-color="#2ec4b6"/>
      <stop id="p1d" offset="100%" stop-color="#3a86ff"/>
    </radialGradient>
    
    <radialGradient id="parentGrad2" cx="50%" cy="50%" r="70%">
      <stop id="p2a" offset="0%" stop-color="#5f0a87"/>
      <stop id="p2b" offset="40%" stop-color="#6a0572"/>
      <stop id="p2c" offset="70%" stop-color="#2d1e6b"/>
      <stop id="p2d" offset="100%" stop-color="#0b2545"/>
    </radialGradient>
    
    <linearGradient id="parentGrad3" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop id="p3a" offset="0%" stop-color="#0f3d91"/>
      <stop id="p3b" offset="50%" stop-color="#3a86ff"/>
      <stop id="p3c" offset="100%" stop-color="#2ec4b6"/>
    </linearGradient>
    
    <!-- Mask for the orb shape -->
    <mask id="orbMask">
      <circle id="maskCircle" cx="50%" cy="50%" r="100" fill="white" />
    </mask>
    
    <!-- Blend mode for the gradients -->
    <filter id="blendFilter">
      <feBlend id="blendMode" mode="screen" in="SourceGraphic" in2="SourceGraphic" />
    </filter>
  </defs>
  
  <!-- Single unified orb with multiple blended layers -->
  <g id="orbGroup">
    <!-- Base layer with mask -->
    <circle id="baseOrb" cx="50%" cy="50%" r="100" fill="url(#parentGrad1)" opacity="0.95" filter="url(#glow)" />
    
    <!-- Overlay layers with seamless blending -->
    <circle id="overlayOrb1" cx="50%" cy="50%" r="100" fill="url(#parentGrad2)" opacity="0.85" filter="url(#turbulence)" style="mix-blend-mode: soft-light;" />
    
    <circle id="overlayOrb2" cx="50%" cy="50%" r="98" fill="url(#parentGrad3)" opacity="0.75" filter="url(#organicBlend)" style="mix-blend-mode: overlay;" />
  </g>
</svg>
<script>
// --- Utility functions ---
function lerp(a, b, t) { return a + (b - a) * t; }
function hslToHex(h, s, l) {
  h /= 360; s /= 100; l /= 100;
  let r, g, b;
  if (s === 0) { r = g = b = l; }
  else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return "#" + [r, g, b].map(x => Math.round(x * 255).toString(16).padStart(2, "0")).join("");
}
function lerpColor(a, b, t) {
  const ah = parseInt(a.replace('#', ''), 16), bh = parseInt(b.replace('#', ''), 16);
  const ar = (ah >> 16) & 0xff, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
  const br = (bh >> 16) & 0xff, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
  const rr = Math.round(ar + (br - ar) * t);
  const rg = Math.round(ag + (bg - ag) * t);
  const rb = Math.round(ab + (bb - ab) * t);
  return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb).toString(16).slice(1);
}

const parentRadius = 100;

function adjustSVGSize() {
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const svg = document.getElementById('orbSVG');
  svg.setAttribute('width', vw);
  svg.setAttribute('height', vh);
  svg.setAttribute('viewBox', `0 0 ${vw} ${vh}`);
}

adjustSVGSize();
window.addEventListener('resize', adjustSVGSize);

function animate() {
  const now = performance.now();
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const cx = vw / 2;
  const cy = vh / 2;
  
  // Animate the mask circle for subtle breathing effect
  const breatheScale = 1 + 0.02 * Math.sin(now * 0.0005);
  const maskRadius = parentRadius * breatheScale;
  document.getElementById('maskCircle').setAttribute('r', maskRadius);
  
  // Animate turbulence for fluid-like movement
  const turbFreqX = 0.01 + 0.005 * Math.sin(now * 0.00017);
  const turbFreqY = 0.01 + 0.005 * Math.cos(now * 0.00019);
  const turbScale = 10 + 5 * Math.sin(now * 0.0003);
  const turbSeed = Math.floor(now * 0.001) % 100;
  document.getElementById('turbulenceFilter').setAttribute('baseFrequency', `${turbFreqX} ${turbFreqY}`);
  document.getElementById('turbulenceFilter').setAttribute('seed', turbSeed);
  
  // Animate gradient positions for flowing effect
  const grad1cx = 50 + 15 * Math.sin(now * 0.0002);
  const grad1cy = 50 + 15 * Math.cos(now * 0.00018);
  const grad2cx = 50 + 15 * Math.sin(now * 0.00022 + 2);
  const grad2cy = 50 + 15 * Math.cos(now * 0.00019 + 1);
  document.getElementById('parentGrad1').setAttribute('cx', `${grad1cx}%`);
  document.getElementById('parentGrad1').setAttribute('cy', `${grad1cy}%`);
  document.getElementById('parentGrad2').setAttribute('cx', `${grad2cx}%`);
  document.getElementById('parentGrad2').setAttribute('cy', `${grad2cy}%`);
  
  // Animate linear gradient angle
  const angle = (now * 0.01) % 360;
  const x1 = 50 + 50 * Math.cos(angle * Math.PI / 180);
  const y1 = 50 + 50 * Math.sin(angle * Math.PI / 180);
  const x2 = 50 + 50 * Math.cos((angle + 180) * Math.PI / 180);
  const y2 = 50 + 50 * Math.sin((angle + 180) * Math.PI / 180);
  document.getElementById('parentGrad3').setAttribute('x1', `${x1}%`);
  document.getElementById('parentGrad3').setAttribute('y1', `${y1}%`);
  document.getElementById('parentGrad3').setAttribute('x2', `${x2}%`);
  document.getElementById('parentGrad3').setAttribute('y2', `${y2}%`);
  
  // Animate gradient colors for first radial gradient
  const grad1Colors = [
    {id:'p1a', base:'#0f3d91', alt:'#2d1e6b'},
    {id:'p1b', base:'#1e6bb8', alt:'#3a86ff'},
    {id:'p1c', base:'#2ec4b6', alt:'#0b2545'},
    {id:'p1d', base:'#3a86ff', alt:'#5f0a87'}
  ];
  
  // Animate gradient colors for second radial gradient
  const grad2Colors = [
    {id:'p2a', base:'#5f0a87', alt:'#0f3d91'},
    {id:'p2b', base:'#6a0572', alt:'#2ec4b6'},
    {id:'p2c', base:'#2d1e6b', alt:'#1e6bb8'},
    {id:'p2d', base:'#0b2545', alt:'#3a86ff'}
  ];
  
  // Animate gradient colors for linear gradient
  const grad3Colors = [
    {id:'p3a', base:'#0f3d91', alt:'#6a0572'},
    {id:'p3b', base:'#3a86ff', alt:'#2d1e6b'},
    {id:'p3c', base:'#2ec4b6', alt:'#5f0a87'}
  ];
  
  // Apply color animations to all gradients with different phases
  [grad1Colors, grad2Colors, grad3Colors].forEach((gradColors, gradIndex) => {
    gradColors.forEach((stop, i) => {
      const phase = now * 0.0001 + i * 0.7 + gradIndex * 1.3;
      const tt = 0.5 + 0.5 * Math.sin(phase + Math.sin(phase * 0.5));
      const color = lerpColor(stop.base, stop.alt, tt);
      document.getElementById(stop.id).setAttribute('stop-color', color);
    });
  });
  
  // Animate orb positions for subtle movement
  const orb1x = cx + 5 * Math.sin(now * 0.0003);
  const orb1y = cy + 5 * Math.cos(now * 0.00025);
  const orb2x = cx + 5 * Math.sin(now * 0.00027 + 2);
  const orb2y = cy + 5 * Math.cos(now * 0.00023 + 1);
  document.getElementById('baseOrb').setAttribute('cx', orb1x);
  document.getElementById('baseOrb').setAttribute('cy', orb1y);
  document.getElementById('overlayOrb1').setAttribute('cx', orb2x);
  document.getElementById('overlayOrb1').setAttribute('cy', orb2y);
  
  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
